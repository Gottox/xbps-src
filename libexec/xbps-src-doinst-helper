#!//bin/bash

PKG_TMPLNAME="$1"

if [ -n "${CONFIG_FILE}" -a -r "${CONFIG_FILE}" ]; then
	. ${CONFIG_FILE}
fi

if [ -n "${MASTERDIR}" ]; then
	export XBPS_MASTERDIR="${MASTERDIR}"
fi

. ${XBPS_SHAREDIR}/shutils/init_funcs.sh
set_defvars
set_cross_defvars

install_src_phase() {
	local f= i= subpkg=

	[ -z $pkgname ] && return 2
	#
	# There's nothing we can do if we are a meta template.
	# Just creating the dir is enough to write the package metadata.
	#
	if [ "$build_style" = "meta-template" ]; then
		mkdir -p $XBPS_DESTDIR/$pkgname-$version
		return 0
	fi

	cd $wrksrc || msg_error "$pkgver: cannot access to wrksrc [$wrksrc]\n"
	if [ -n "$build_wrksrc" ]; then
		cd $build_wrksrc \
			|| msg_error "$pkgver: cannot access to build_wrksrc [$build_wrksrc]\n"
	fi

	# Run pre_install func.
	if [ ! -f $XBPS_PRE_INSTALL_DONE ]; then
		if declare -f pre_install >/dev/null; then
			run_func pre_install
			touch -f $XBPS_PRE_INSTALL_DONE
		fi
	fi

	# do_install()
	if [ -r $XBPS_HELPERSDIR/${build_style}.sh ]; then
		. $XBPS_HELPERSDIR/${build_style}.sh
	fi
	cd $wrksrc
	[ -n "$build_wrksrc" ] && cd $build_wrksrc
	if declare -f do_install >/dev/null; then
		run_func do_install
	fi

	# Run post_install func.
	if [ ! -f $XBPS_POST_INSTALL_DONE ]; then
		cd $wrksrc
		[ -n "$build_wrksrc" ] && cd $build_wrksrc
		if declare -f post_install >/dev/null; then
			run_func post_install
			touch -f $XBPS_POST_INSTALL_DONE
		fi
	fi

	# Remove libtool archives by default.
	if [ -z "$keep_libtool_archives" ]; then
		msg_normal "$pkgver: removing libtool archives...\n"
		find ${DESTDIR} -type f -name \*.la -delete
	fi
	# Remove bytecode python generated files.
	msg_normal "$pkgver: removing python bytecode archives...\n"
	find ${DESTDIR} -type f -name \*.py[co] -delete

	# Always remove perllocal.pod and .packlist files.
	if [ "$pkgname" != "perl" ]; then
		find ${DESTDIR} -type f -name perllocal.pod -delete
		find ${DESTDIR} -type f -name .packlist -delete
	fi
	# Remove empty directories by default.
	for f in $(find ${DESTDIR} -depth -type d); do
		rmdir $f 2>/dev/null && \
			msg_warn "$pkgver: removed empty dir: ${f##${DESTDIR}}\n"
	done
	#
	# Build subpackages if found.
	#
	for subpkg in ${subpackages}; do
		msg_normal "$sourcepkg: preparing subpackage '${subpkg}'...\n"
		if [ ! -f $XBPS_SRCPKGDIR/${sourcepkg}/${subpkg}.template ]; then
			msg_error "$sourcepkg: cannot find '${subpkg}' subpkg build template!\n"
		fi
		. $XBPS_SRCPKGDIR/${sourcepkg}/${subpkg}.template
		pkgname=${subpkg}
		set_tmpl_common_vars
		if [ -f ${wrksrc}/.xbps_${XBPS_CROSS_TRIPLET}_do_install_${pkgname}_done ]; then
			msg_warn "$sourcepkg: skipping '$pkgname' subpkg, already installed into destdir.\n"
			continue
		fi
		cd $wrksrc
		[ -n "$build_wrksrc" ] && cd $build_wrksrc
		if declare -f do_install >/dev/null; then
			run_func do_install
			touch -f ${wrksrc}/.xbps_${XBPS_CROSS_TRIPLET}_do_install_${pkgname}_done
			# Remove empty directories by default.
			for f in $(find ${DESTDIR} -depth -type d); do
				rmdir $f 2>/dev/null && \
					msg_warn "$pkgver: removed empty dir: ${f##${DESTDIR}}\n"
			done
		fi
	done
	# Remove empty directories by default.
	for f in $(find ${DESTDIR} -depth -type d); do
		rmdir $f 2>/dev/null && \
			msg_warn "$pkgver: removed empty dir: ${f##${DESTDIR}}\n"
	done
	touch -f $XBPS_INSTALL_DONE
}

[ -z "$PKG_TMPLNAME" ] && exit 2

setup_tmpl $PKG_TMPLNAME
install_src_phase $pkgname

exit 0
